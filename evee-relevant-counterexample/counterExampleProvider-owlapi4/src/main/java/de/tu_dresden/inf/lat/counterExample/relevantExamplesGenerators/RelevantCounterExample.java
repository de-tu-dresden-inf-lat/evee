package de.tu_dresden.inf.lat.counterExample.relevantExamplesGenerators;

import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import de.tu_dresden.inf.lat.counterExample.ELKModelGenerator;
import de.tu_dresden.inf.lat.counterExample.data.RelationReasons;
import org.apache.log4j.Logger;
import org.semanticweb.owlapi.model.OWLAxiom;
import org.semanticweb.owlapi.model.OWLClassExpression;
import org.semanticweb.owlapi.model.OWLObjectSomeValuesFrom;
import org.semanticweb.owlapi.model.OWLOntology;
import org.semanticweb.owlapi.model.OWLOntologyCreationException;

import com.github.jsonldjava.shaded.com.google.common.collect.Sets;

import de.tu_dresden.inf.lat.model.data.Element;
import de.tu_dresden.inf.lat.model.data.ElkModel;
import de.tu_dresden.inf.lat.model.data.EntryPair;
import de.tu_dresden.inf.lat.model.data.Relation;
import de.tu_dresden.inf.lat.model.tools.ToOWLTools;

/**
 * @author Christian Alrabbaa
 *
 */
public abstract class RelevantCounterExample {
	// TODO save extracted counter examples
	private static final Logger logger = Logger.getLogger(RelevantCounterExample.class);

	protected final ElkModel model;
	protected final OWLAxiom conclusion;
	protected final OWLOntology module;
	protected final RelationReasons relationReasons;

	public RelevantCounterExample(ELKModelGenerator elkCounterModelGenerator) throws OWLOntologyCreationException {
		this.model = elkCounterModelGenerator.generateFullRelevantCanonicalModel();
		this.conclusion = elkCounterModelGenerator.getConclusion();
		this.module = elkCounterModelGenerator.getOntology();
		this.relationReasons = new RelationReasons();
	}

	public RelationReasons getRelationReasons() {
		return relationReasons;
	}

	/**
	 * The size of the original model generated by {@code ELKCounterModel}
	 * 
	 * @return
	 */
	public int getModelSize() {
		return this.model.getRawModelElements().size();
	}

	/**
	 * Return the total number of edges in the given set of elements
	 * 
	 * @param model
	 * @return
	 */
	public int getEdgeCount(Set<Element> model) {
		int res = 0;
		for (Element e : model) {
			res = res + e.getRelations().stream().filter(x -> x.isForward()).collect(Collectors.toSet()).size();
		}
		return res;
	}

	/**
	 * Return the max size of the set of labels among all elements of the model
	 * 
	 * @param model
	 * @return
	 */
	public int getMaxTypesSize(Set<Element> model) {
		int res = 0;
		for (Element e : model) {
			if (e.getTypes().size() > res)
				res = e.getTypes().size();
		}
		return res;
	}

	/**
	 * Return the number of labels in the given set of elements
	 * 
	 * @param model
	 * @return
	 */
	public int getTypesCount(Set<Element> model) {
		Set<OWLClassExpression> res = new HashSet<>();
		for (Element e : model) {
			res.addAll(e.getTypes().stream().collect(Collectors.toSet()));
		}
		return res.size();
	}

	/**
	 * Return the number of original labels in the given set of elements
	 * 
	 * @param model
	 * @return
	 */
	public int getOriginalTypesCount(Set<Element> model) {
		Set<OWLClassExpression> res = new HashSet<>();
		for (Element e : model) {
			res.addAll(e.getOriginalTypes(this.model.getMapper()).stream().collect(Collectors.toSet()));
		}
		return res.size();
	}

	public Map<Element, Set<EntryPair<OWLClassExpression, Relation>>> getElementLabelToRelationMap() {
		return this.model.getElementTypeToEdgeMap();
	}

	public abstract Set<Element> generate();

	/**
	 * Remove reverse edges pointing to elements that are not part of the model
	 * anymore
	 *
	 */
	protected void cleanReverseEdges(Set<Element> model) {
		Set<Relation> toRemove = new HashSet<>();
		for (Element e : model) {
			for (Relation r : e.getRelations()) {
				if (r.isBackward())
					if (!model.contains(r.getElement1()))
						toRemove.add(r);
			}
			toRemove.forEach(e::removeRelation);
		}
	}

	protected Element getElementFrom(Element toFind, Set<Element> elements) {
		return elements.stream().filter(x -> x.equals(toFind)).collect(Collectors.toList()).get(0);
	}

	/**
	 * Return a set of elements that are only Reachable from the representative of
	 * the left hand side element
	 */
	protected Set<Element> filterReachableElements(Set<Element> reachableFromLHSElement, Element rHSElement,
			Set<Element> model) {
		Set<Element> onlyReachableFromLHSElement = new HashSet<>();
		Set<Element> reachableFromRHSElement = new HashSet<>();
		Set<Relation> processedRelations = new HashSet<>();

		fillReachableElementsSet(rHSElement, reachableFromRHSElement, model, processedRelations);

		for (Element e : reachableFromLHSElement)
			if (!reachableFromRHSElement.contains(e))
				onlyReachableFromLHSElement.add(e);

		return onlyReachableFromLHSElement;
	}

	protected void fillReachableElementsSet(Element element, Set<Element> reachableElements, Set<Element> model,
			Set<Relation> processedRelations) {
		Element targetElement;

		// Added here instead of target element
		reachableElements.add(element);

		for (Relation r : element.getRelations()) {
			if (r.isForward()) {
				if (processedRelations.contains(r))
					continue;
				processedRelations.add(r);

				targetElement = getElementFrom(r.getElement2(), model);
				// reachableElements.add(targetElement);
				fillReachableElementsSet(targetElement, reachableElements, model, processedRelations);
			}
		}
	}

	protected void updateMap(Relation relation, boolean value, Map<Relation, Set<Boolean>> map) {
		if (map.containsKey(relation))
			map.get(relation).add(value);
		else
			map.put(relation, Sets.newHashSet(value));

	}

	protected boolean evaluateFound(Relation relation, Map<Relation, Set<Boolean>> map) {
		Set<Boolean> foundInstances = map.get(relation);
		if (foundInstances == null)
			return false;
		if (foundInstances.contains(true))
			return true;
		return false;
	}

	protected Set<Relation> FilterIncomingEdges(Element element) {
		Set<Relation> res = new HashSet<>();

		for (Relation r : element.getRelations())
			if (r.isForward())
				res.add(r);

		return res;
	}

	/**
	 * Returns a set of all successors of all elements in "intermediate". update the
	 * final model with updated elements from the current depth
	 * 
	 * @param intermediate
	 * @return {@code Set<Element>}
	 */
	protected Set<Element> addSuccessorsOfAll(Set<Element> intermediate, Set<Element> finalModel) {
		Element element, finalizedElement;
		Set<Element> newIntermediate = new HashSet<>();

		for (Element e : intermediate) {
			finalizedElement = this.model.getFinilizedElement(e);
			element = new Element(finalizedElement.getName());
			element.addTypes(finalizedElement.getTypes());
			for (Relation r : finalizedElement.getRelations()) {
				element.addRelation(r);
				if (r.isForward()) {
//					element.addRelation(r);
					if (!finalModel.contains(r.getElement2()))
						newIntermediate.add(r.getElement2());
				}
			}
			finalModel.add(element);
		}
		return Collections.unmodifiableSet(newIntermediate);
	}

	protected static final ToOWLTools owlTools = ToOWLTools.getInstance();

	/**
	 * Return the OWLClassExpression mapped to the input alias
	 * 
	 * @param alias
	 * @return
	 */
	public OWLClassExpression getConceptFromAlias(OWLClassExpression alias) {
		OWLClassExpression res = getRestrictionFromAlias(alias);

		if (!res.equals(alias)) {
			OWLObjectSomeValuesFrom restriction = (OWLObjectSomeValuesFrom) this.model.getMapper()
					.getRestrictionMapper().getClass2Restriction().get(alias);
			OWLClassExpression filler = restriction.getFiller();

			return owlTools.getOWLExistentialRestriction(restriction.getProperty(), getConceptFromAlias(filler));
		}

		res = getConjunctionFromAlias(alias);
		if (!res.equals(alias)) {
			Set<OWLClassExpression> conjuncts = this.model.getMapper().getConjunctionMapper().getClass2Conjunction()
					.get(alias).asConjunctSet();
			Set<OWLClassExpression> newConjuncts = new HashSet<>();
			for (OWLClassExpression conjunct : conjuncts) {
				newConjuncts.add(getConceptFromAlias(conjunct));
			}
			return owlTools.getOWLConjunction(newConjuncts);
		}

		return res;
	}

	protected OWLClassExpression getRestrictionFromAlias(OWLClassExpression alias) {
		if (this.model.getMapper().getRestrictionMapper().getClass2Restriction().containsKey(alias))
			return this.model.getMapper().getRestrictionMapper().getClass2Restriction().get(alias);
		return alias;
	}

	protected OWLClassExpression getConjunctionFromAlias(OWLClassExpression alias) {
		if (this.model.getMapper().getConjunctionMapper().getClass2Conjunction().containsKey(alias))
			return this.model.getMapper().getConjunctionMapper().getClass2Conjunction().get(alias);
		return alias;
	}

	protected OWLClassExpression makeConcept(OWLClassExpression toRemove, OWLClassExpression toModify) {
//		System.out.println("elemet -> " + e);
//		System.out.println("toremove -> " + toRemove);
//		System.out.println("res from alias" + restrictionFromAlias);

		if (!(toModify instanceof OWLObjectSomeValuesFrom))
			return toModify;

		OWLObjectSomeValuesFrom restriction = (OWLObjectSomeValuesFrom) toModify;
		Set<OWLClassExpression> fillerSet = Sets.newHashSet(restriction.getFiller().asConjunctSet());
		fillerSet.remove(toRemove);

		if (fillerSet.size() == 0) {
			fillerSet.add(owlTools.getOWLTop());
		}

		if (fillerSet.size() == 1) {
			OWLClassExpression exp = fillerSet.iterator().next();
			return owlTools.getOWLExistentialRestriction(restriction.getProperty(), exp);
		}

		Set<OWLClassExpression> newFillerSet = new HashSet<>();
		for (OWLClassExpression exp : fillerSet) {
			newFillerSet.add(makeConcept(toRemove, exp));
		}

		return owlTools.getOWLExistentialRestriction(restriction.getProperty(),
				owlTools.getOWLConjunction(newFillerSet));
	}

	public ElkModel getElkModel() {
		return model;
	}

}
