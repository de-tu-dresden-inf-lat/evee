% This is the completely unoptimized, literal encoding
% of the EL reasoning calculus published in Table 2 of 
% Franz Baader, Sebastian Brandt and Carsten Lutz:
% "Pushing the EL Envelope", IJCAI, 2005
% (without concrete domains and nominals)

@prefix nf: <http://rulewerk.semantic-web.org/normalForm/> .
@prefix inf: <http://rulewerk.semantic-web.org/inferred/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix genid: <https://rulewerk.semantic-web.org/.well-known/genid/> .

%%% Mark classes:
ClassObject(owl:someValuesFrom) .
ClassObject(rdf:first) .
ClassObject(rdfs:subClassOf) .
ClassObject(owl:equivalentClass) .
ClassSubject(rdfs:subClassOf) .
ClassSubject(owl:equivalentClass) .
class(?O) :- TRIPLE(?X, ?P, ?O), ClassObject(?P) .
class(?X) :- TRIPLE(?X, ?P, ?O), ClassSubject(?P) .

%%% Distinguish auxiliary class expressions from primary classes:

%% Mark auxiliary existential role restrictions:
synEx(?Y,?P,?X), auxClass(?X) :- TRIPLE(?X, owl:someValuesFrom, ?Y), TRIPLE(?X, owl:onProperty, ?P) .

%% Mark auxiliary conjunctions:
next(?L1,?L2) :- TRIPLE(?L1,rdf:rest,?L2) .
   first(?L1) :- TRIPLE(?X, owl:intersectionOf, ?L1) .
nonfirst(?L2) :- first(?L1), next(?L1,?L2) .
nonfirst(?L2) :- nonfirst(?L1), next(?L1,?L2) .
    last(?Ln) :- next(?Ln,rdf:nil) .
  nonlast(?L) :- next(?L,?Ln), last(?Ln) .
 nonlast(?L1) :- next(?L1,?L2), nonlast(?L2) .
    in(?L,?C) :- TRIPLE(?L,rdf:first,?C) .

% Mark conjunctions:
synConj(?X,?C1,?C2), auxClass(?X) :-
	TRIPLE(?X, owl:intersectionOf, ?L1), next(?L1,?L2), last(?L2), in(?L1,?C1), in(?L2,?C2) .
synConj(?X,?C1,?L2), auxClass(?X) :-
	TRIPLE(?X, owl:intersectionOf, ?L1), next(?L1,?L2), nonlast(?L2), in(?L1,?C1) .
synConj(?L1,?C1,?L2), auxClass(?L1) :-
	nonfirst(?L1), next(?L1,?L2), nonlast(?L2), in(?L1,?C1) .
synConj(?L1,?C1,?C2), auxClass(?L1) :-
	nonfirst(?L1), next(?L1,?L2), last(?L2), in(?L1,?C1), in(?L2,?C2) .

%%% The other classes are "main classes" that are not normalised:
nf:isMainClass(?X) :- class(?X), ~auxClass(?X) .

%%% Normalise auxiliary nested class expressions:
            repOf(?X,?X) :- nf:isMainClass(?X) . % keep main classes unchanged

    synExRep(?X,?P,?Rep) :- synEx(?Y,?P,?X), repOf(?Y,?Rep) .
 nf:exists(!New,?P,?Rep) :- synExRep(?X,?P,?Rep) .
represents(?N,nf:exists) :- nf:exists(?N,?P,?Rep) , synExRep(?X,?P,?Rep).
            repOf(?X,?N) :- synExRep(?X,?P,?Rep), nf:exists(?N,?P,?Rep) .

   nf:conj(!New,?R1,?R2) :- synConj(?X,?C1,?C2), repOf(?C1,?R1), repOf(?C2,?R2) .
represents(?New,nf:conj) :- nf:conj(?New,?R1,?R2), repOf(?C1,?R1), repOf(?C2,?R2), synConj(?X,?C1,?C2).
         	repOf(?X,?N) :- synConj(?X,?C1,?C2), repOf(?C1,?R1), repOf(?C2,?R2), nf:conj(?N,?R1,?R2) .

%%% Extract old-style property chains:
nf:subPropChain(?S,?T,?R), nf:subProp(?R,?R) :-
	TRIPLE(?L,rdfs:subPropertyOf,?R), TRIPLE(?L,owl:propertyChain,?L1),
	in(?L1,?S), next(?L1,?L2), in(?L2,?T) .


%%% Initialise subsumption axioms:
                         prepareSco(?X,?Y) :- TRIPLE(?X, rdfs:subClassOf, ?Y) .
      prepareSco(?X,?Y), prepareSco(?Y,?X) :- TRIPLE(?X, owl:equivalentClass, ?Y) .
   prepareSco(?Y, ?D), prepareSco(?Y, ?E), :- nf:conj(?Y,?D,?E) .
nf:subClassOf(?RX,?RY), nf:isSubClass(?RX) :- prepareSco(?X,?Y), repOf(?X,?RX), repOf(?Y,?RY) .

%%% express different kinds of sequents
nf:subClassConj(?RD,?RE,?RY) :- nf:conj(?Y,?D,?E), repOf(?RY,?Y), repOf(?D,?RD), repOf(?E,?RE) .
nf:subClassEx(?R,?RB,?RY) :- nf:exists(?Y,?R,?B), repOf(?RY,?Y), repOf(?B,?RB) .
nf:supClassEx(?RY,?R,?RB) :- nf:exists(?Y,?R,?B), repOf(?RY,?Y), repOf(?B,?RB) .


%%% Initialise disjointness:
nf:subClassOf(!C,owl:Nothing), nf:conj(!C,?X,?Y), nf:isSubClass(!C), nf:isSubClass(?X), nf:isSubClass(?Y)
	:- TRIPLE(?X,owl:disjointWith,?Y) .
represents(?C,nf:subClassOf) :- nf:subClassOf(?C,owl:Nothing), nf:conj(?C,?X,?Y), nf:isSubClass(?C), TRIPLE(?X,owl:disjointWith,?Y)  .

%%% Mark classes in subclass position recursively:
                     nf:isSubClass(?D) :- nf:exists(?C, ?P, ?D), nf:isSubClass(?C) .
nf:isSubClass(?C1), nf:isSubClass(?C2) :- nf:conj(?X, ?C1, ?C2), nf:isSubClass(?X) .

%%% Precompute role hierarchy:
directSubProp(?R,?S) :- TRIPLE(?R,rdfs:subPropertyOf,?S) .
% Initialise role hierarchy only for roles in subclass positions:
nf:subProp(?P,?P) :- nf:exists(?C,?P,?D), nf:isSubClass(?C) . 
nf:subProp(?R,?T) :- nf:subProp(?R,?S), directSubProp(?S,?T) .
 
%% Initialize 'S' sets 
%% D ∈ S(C) is represented as S(C,D)
%% (C,D) ∈ R(r) is represented as R(C,r,D)

       S(?A,?A) :- class(?A) .
S(?A,owl:Thing) :- class(?A) .


%%% Inference rules

% CR1
S(?C,?D) :- S(?C,?Cp), nf:subClassOf(?Cp,?D) .

% CR2
S(?C,?D) :- S(?C,?C1), S(?C, ?C2), nf:subClassConj(?C1,?C2,?D) .

% CR3
R(?C,?R,?D) :- S(?C,?Cp), nf:supClassEx(?Cp,?R,?D) .

% CR4
S(?C,?E) :- R(?C,?R,?D), S(?D,?Dp), nf:subClassEx(?R,?Dp,?E) .

% CR5
S(C,owl:Nothing) :- R(?C,?R,?D), S(?D,owl:Nothing) .

% (CR6-9 are for nominals and concrete domains.)

% CR10
R(?C,?S,?D) :- R(?C,?R,?D), nf:subProp(?R,?S) .

% CR11
R(?C,?R3,?E) :- R(?C,?R1,?D), R(?D,?R2,?E), nf:subPropChain(?R1,?R2,?R3) .


%%% Extract final results for main classes

mainSubClassOf(?A,?B) :-
	S(?A,?B), nf:isMainClass(?A), nf:isMainClass(?B) .
