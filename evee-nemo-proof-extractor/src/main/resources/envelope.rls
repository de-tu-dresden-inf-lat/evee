% This is the completely unoptimized, literal encoding
% of the EL reasoning calculus published in Fig. 6.2 of 
% Franz Baader, Ian Horrocks, Carsten Lutz and Uli Sattler:
% "An Introduction to Description Logic", Cambridge University Press, 2017
% (slightly extended for role hierarchies and bottom)
%
% First this ruleset normalises an EL ontology in OWL/RDF encoding.
% The normalisation coincides with the normalisation of the calculus defined on p143, Fig. 6.1..
%
% The ruleset computes facts for the following predicates:
%  nf:isMainClass(?C): ?C is an "interesting" class (not just an auxiliary class expression)
%  nf:isSubClass(?C): ?C occurs in a subclass position (i.e., negatively) 
%  nf:conj(?C,?D1,?D2): ?C is the conjunction of ?D1 and ?D2
%  nf:exists(?C,?P,?D): ?C is the existential restriction of property ?P with values from ?D
%  nf:subClassOf(?C,?D): ?C is syntactically specified to be a subclass of ?D 
%  nf:subClassConj(?A,?B,?C): The conjunction of ?A and ?B is declared a subclass of ?C.
%  nf:subClassEx(?R,?A,?B): ∃?R.?A is declared a subclass of ?B
%  nf:supClassEx(?A,?R,?B): ?A is declared a subclass of ∃?R.?B
%  nf:subPropChain(?S1,?S2,?R): there was a role chain axiom ?S1 o ?S2 -> ?R
%  nf:subProp(?R,?S): ?R is a subproperty of ?S (directly or indirectly) 
% 
% Unsupported OWL EL features include: oneOf, allDisjoint.
% The encoding used for property chains is also slightly antique.

@prefix nf: <http://rulewerk.semantic-web.org/normalForm/> .
@prefix inf: <http://rulewerk.semantic-web.org/inferred/> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sct: <http://www.ihtsdo.org/owlname#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix genid: <https://rulewerk.semantic-web.org/.well-known/genid/> .

% Read data from Turtle file:
@import TRIPLE :- rdf{resource="ont.ttl"} .

%%% Mark classes:
ClassObject(owl:someValuesFrom) .
ClassObject(rdf:first) .
ClassObject(rdfs:subClassOf) .
ClassObject(owl:equivalentClass) .
ClassSubject(rdfs:subClassOf) .
ClassSubject(owl:equivalentClass) .
class(?O) :- TRIPLE(?X, ?P, ?O), ClassObject(?P) .
class(?X) :- TRIPLE(?X, ?P, ?O), ClassSubject(?P) .

%%% Distinguish auxiliary class expressions from primary classes in input:

%% Mark existential role restrictions:
exists(?X,?R,?Y), auxClass(?X) :- TRIPLE(?X, owl:someValuesFrom, ?Y), TRIPLE(?X, owl:onProperty, ?R) .

%% Mark conjunctions:
next(?L1,?L2) :- TRIPLE(?L1,rdf:rest,?L2) .
   first(?L1) :- TRIPLE(?X, owl:intersectionOf, ?L1) .
nonfirst(?L2) :- first(?L1), next(?L1,?L2) .
nonfirst(?L2) :- nonfirst(?L1), next(?L1,?L2) .
    last(?Ln) :- next(?Ln,rdf:nil) .
  nonlast(?L) :- next(?L,?Ln), last(?Ln) .
 nonlast(?L1) :- next(?L1,?L2), nonlast(?L2) .
    in(?L,?C) :- TRIPLE(?L,rdf:first,?C) .
	
conj(?X,?C1,?C2), auxClass(?X) :-
	TRIPLE(?X, owl:intersectionOf, ?L1), next(?L1,?L2), last(?L2), in(?L1,?C1), in(?L2,?C2) .
conj(?X,?C1,?L2), auxClass(?X) :-
	TRIPLE(?X, owl:intersectionOf, ?L1), next(?L1,?L2), nonlast(?L2), in(?L1,?C1) .
conj(?L1,?C1,?L2), auxClass(?L1) :-
	nonfirst(?L1), next(?L1,?L2), nonlast(?L2), in(?L1,?C1) .
conj(?L1,?C1,?C2), auxClass(?L1) :-
	nonfirst(?L1), next(?L1,?L2), last(?L2), in(?L1,?C1), in(?L2,?C2) .

% mark subClass axioms
                    subClass(?X,?Y) :- TRIPLE(?X, rdfs:subClassOf, ?Y) .
subClass(?X,?Y), subClass(?Y,?X) :- TRIPLE(?X, owl:equivalentClass, ?Y) .

%%% The other classes are "main classes" aka named conecepts:
nf:mainClass(?X) :- class(?X), ~auxClass(?X) .


%%% normalise ontology to only contain GCIs of form A ⊑B, A1 ⊓A2 ⊑B, A ⊑∃r.B or ∃r.A ⊑B 
%%% (see Fig. 6.1 on p143)

% NF0
subClass(?D,!A), subClass(!A,?E), nf:mainClass(!A) :-  subClass(?D,?E), auxClass(?D), auxClass(?E) .

% % NF1_r & NF1_l
nf:subClassConj(?A1,?A2,?B)
      :- subClass(?X,?B), conj(?X,?A1,?A2), nf:mainClass(?A1), nf:mainClass(?A2), nf:mainClass(?B) .

nf:subClassConj(!A1,!A2,?B), subClass(?C,!A1), subClass(?D,!A2), nf:mainClass(!A1), nf:mainClass(!A2)
      :- subClass(?X,?B), conj(?X,?C,?D), auxClass(?C), auxClass(?D), nf:mainClass(?B) .

nf:subClassConj(?C,!A,?B), subClass(?D,!A), nf:mainClass(!A)
      :- subClass(?X,?B), conj(?X,?C,?D), nf:mainClass(?C), auxClass(?D), nf:mainClass(?B) .

nf:subClassConj(!A,?D,?B), subClass(?C,!A), nf:mainClass(!A)
      :- subClass(?X,?B), conj(?X,?C,?D), auxClass(?C), nf:mainClass(?D), nf:mainClass(?B) .

% NF2
nf:subClassEx(?R,!A,?B), subClass(?D,!A), nf:mainClass(!A)
    :- subClass(?X,?B), exists(?X,?R,?D), auxClass(?D), nf:mainClass(?B) .

nf:subClassEx(?R,?D,?B)
    :- subClass(?X,?B), exists(?X,?R,?D), nf:mainClass(?D), nf:mainClass(?B) .

% NF3
nf:supClassEx(?B,?R,!A), subClass(!A,?D), nf:mainClass(!A)
    :- subClass(?B,?X), exists(?X,?R,?D), auxClass(?D), nf:mainClass(?B) .

nf:supClassEx(?B,?R,?D) 
    :- subClass(?B,?X), exists(?X,?R,?D), nf:mainClass(?D), nf:mainClass(?B) .

% NF4
subClass(?B, ?D), subClass(?B, ?E) :-  subClass(?B,?X), conj(?X,?D,?E), nf:mainClass(?B). 

% extract normalised subClass axioms
nf:subClass(?A,?B) :- subClass(?A,?B), nf:mainClass(?A), nf:mainClass(?B) .

% Initialise disjointness: TODO
% nf:subClassOf(!C,owl:Nothing), nf:conj(!C,?X,?Y), nf:isSubClass(!C), nf:isSubClass(?X), nf:isSubClass(?Y)
% :- TRIPLE(?X,owl:disjointWith,?Y) .

%%% Precompute role hierarchy: 
directSubProp(?R,?S) :- TRIPLE(?R,rdfs:subPropertyOf,?S) .
% Initialise role hierarchy only for roles in subclass positions:
nf:subProp(?P,?P) :- nf:supClassEx(_,?P,_) . 
nf:subProp(?R,?T) :- directSubProp(?R,?S), nf:subProp(?S,?T) .


%% Initialize classification algorithm 
inf:subClass(?A,?B) :- nf:subClass(?A,?B) . %TODO twice the same predicate -> optimize

%%% Inference rules, instantiated for all possible combinations of types of sequents

% CR1
#[name("CR1")]
inf:subClass(?A,?A) :- nf:mainClass(?A) .

% CR2
#[name("CR2")]
inf:subClass(?A,owl:Thing) :- nf:mainClass(?A) .

% CR3
#[name("CR3")]
inf:subClass(?A1,?A3) :- inf:subClass(?A1,?A2), inf:subClass(?A2,?A3) .

% CR4
#[name("CR4")]
inf:subClass(?A,?B) :- inf:subClass(?A,?A1), inf:subClass(?A,?A2), nf:subClassConj(?A1,?A2,?B) .

% CR5, extended for role hierarchies
#[name("CR5")]
inf:subClass(?A,?B) :-
     nf:supClassEx(?A,?R,?A1), inf:subClass(?A1,?B1), nf:subProp(?R,?S), nf:subClassEx(?S,?B1,?B) .

% R_\bot from ELK
#[name("R_⊥")]
inf:subClass(?E,owl:Nothing) :-
	inf:supClassEx(?E,?R,?C), inf:subClass(?C,owl:Nothing) .


%%% Extract final results for main classes %TODO
mainSubClassOf(?A,?B) :-
	inf:subClass(?A,?B), nf:mainClass(?A), nf:mainClass(?B) .