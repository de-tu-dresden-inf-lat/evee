% This is the completely unoptimized, literal encoding
% of the EL reasoning calculus published in Fig. 6.2 of 
% Franz Baader, Ian Horrocks, Carsten Lutz and Uli Sattler:
% "An Introduction to Description Logic", Cambridge University Press, 2017
% (slightly extended for role hierarchies and bottom)
%
% First this ruleset normalises an EL ontology in OWL/RDF encoding.
% The normalisation coincides with the normalisation of the calculus defined on p143, Fig. 6.1..
% Most of this normalisation is inherent to the Turtle triple format. Only Rule NF4 is computed here explicitly.
%
% The ruleset computes facts for the following predicates:
%  nf:isMainClass(?C): ?C is an "interesting" class (not just an auxiliary class expression) i.e. named concept
%  nf:conj(?C,?D1,?D2): ?C is the conjunction of ?D1 and ?D2
%  nf:exists(?C,?P,?D): ?C is the existential restriction of property ?P with values from ?D
%  nf:subClassOf(?C,?D): ?C is syntactically specified to be a subclass of ?D 
%  nf:subClassConj(?A,?B,?C): The conjunction of ?A and ?B is declared a subclass of ?C.
%  nf:subClassEx(?R,?A,?B): ∃?R.?A is declared a subclass of ?B
%  nf:supClassEx(?A,?R,?B): ?A is declared a subclass of ∃?R.?B
%  nf:subProp(?R,?S): ?R is a subproperty of ?S (directly or indirectly) 
% 
% Unsupported OWL EL features include: oneOf, allDisjoint.

@prefix nf: <http://rulewerk.semantic-web.org/normalForm/> .
@prefix inf: <http://rulewerk.semantic-web.org/inferred/> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

% Read data from Turtle file:
@import TRIPLE :- rdf{resource="ont.ttl"} .

%%% Mark classes:
ClassObject(owl:someValuesFrom) .
ClassObject(owl:allValuesFrom) .
ClassObject(owl:onClass) .
ClassObject(owl:complementOf) .
ClassObject(rdf:first) .
ClassObject(rdfs:subClassOf) .
ClassObject(owl:equivalentClass) .
ClassSubject(rdfs:subClassOf) .
ClassSubject(owl:equivalentClass) .
class(?O) :- TRIPLE(?X, ?P, ?O), ClassObject(?P) .
class(?X) :- TRIPLE(?X, ?P, ?O), ClassSubject(?P) .

%%% Distinguish auxiliary class expressions from primary classes:

repOf(?X,!N), auxClass(?X) :- TRIPLE(?X, owl:complementOf, _) .
repOf(?X,!N), auxClass(?X) :- TRIPLE(?X, owl:allValuesFrom, _), TRIPLE(?X, owl:onProperty, _).

%% number restr. are encoded as union of one element
numEq(!N,?INT,?R,?C), repOf(?X1,!N), auxClass(?X1),  auxClass(?X2) :- 
    TRIPLE(?X1, owl:unionOf, ?L1), last(?L1), in(?L1,?X2), 
    TRIPLE(?X2, owl:qualifiedCardinality, ?INT), TRIPLE(?X2, owl:onClass, ?C), TRIPLE(?X2, owl:onProperty, ?R) .

numMax(!N,?INT,?R,?C), repOf(?X1,!N), auxClass(?X1),  auxClass(?X2) :- 
    TRIPLE(?X1, owl:unionOf, ?L1), last(?L1), in(?L1,?X2), 
    TRIPLE(?X2, owl:maxQualifiedCardinality, ?INT), TRIPLE(?X2, owl:onClass, ?C), TRIPLE(?X2, owl:onProperty, ?R) .

numMin(!N,?INT,?R,?C), repOf(?X1,!N), auxClass(?X1),  auxClass(?X2) :- 
    TRIPLE(?X1, owl:unionOf, ?L1), last(?L1), in(?L1,?X2), 
    TRIPLE(?X2, owl:minQualifiedCardinality, ?INT), TRIPLE(?X2, owl:onClass, ?C), TRIPLE(?X2, owl:onProperty, ?R) .

%% Mark auxiliary existential role restrictions:
synEx(?Y,?P,?X), auxClass(?X) :- TRIPLE(?X, owl:someValuesFrom, ?Y), TRIPLE(?X, owl:onProperty, ?P) .

%% Mark auxiliary existential role restrictions:
synEx(?Y,?P,?X), auxClass(?X) :- TRIPLE(?X, owl:someValuesFrom, ?Y), TRIPLE(?X, owl:onProperty, ?P) .

%% Mark auxiliary lists:
next(?L1,?L2) :- TRIPLE(?L1,rdf:rest,?L2) .
   
    last(?Ln) :- next(?Ln,rdf:nil) .
  nonlast(?L) :- next(?L,?Ln), last(?Ln) .
 nonlast(?L1) :- next(?L1,?L2), nonlast(?L2) .
    in(?L,?C) :- TRIPLE(?L,rdf:first,?C) .

first(?L1)    :- TRIPLE(?X, owl:intersectionOf, ?L1) .
nonfirst(?L2) :- first(?L1), next(?L1,?L2) .
nonfirst(?L2) :- nonfirst(?L1), next(?L1,?L2) .

firstDisj(?L1)     :- TRIPLE(?X, owl:unionOf, ?L1) .
nonfirstDisj(?L2)  :- firstDisj(?L1), next(?L1,?L2) .
nonfirstDisj(?L2)  :- nonfirstDisj(?L1), next(?L1,?L2) .

%% Initialise disjointness:
#[name("disjoint")]
TRIPLE(!C, owl:intersectionOf, !L1), TRIPLE(!L1,rdf:first,?X), 
TRIPLE(!L1,rdf:rest,!L2), TRIPLE(!L2,rdf:first,?Y), TRIPLE(!L2,rdf:rest,rdf:nil),
TRIPLE(!C,rdfs:subClassOf, owl:Nothing)
	:- TRIPLE(?X,owl:disjointWith,?Y) .
	
%% Mark conjunctions:
synConj(?X,?C1,?C2), auxClass(?X) :-
	TRIPLE(?X, owl:intersectionOf, ?L1), next(?L1,?L2), last(?L2), in(?L1,?C1), in(?L2,?C2) .
synConj(?X,?C1,?L2), auxClass(?X) :-
	TRIPLE(?X, owl:intersectionOf, ?L1), next(?L1,?L2), nonlast(?L2), in(?L1,?C1) .
synConj(?L1,?C1,?L2), auxClass(?L1) :-
	nonfirst(?L1), next(?L1,?L2), nonlast(?L2), in(?L1,?C1) .
synConj(?L1,?C1,?C2), auxClass(?L1) :-
	nonfirst(?L1), next(?L1,?L2), last(?L2), in(?L1,?C1), in(?L2,?C2) .

% mark disjunctions
disj(?X,?C,?D), auxClass(?X) :- TRIPLE(?X, owl:unionOf, ?L1),  next(?L1,?L2), last(?L2), in(?L1,?C), in(?L2,?D) .
disj(?X,?C,?L2), auxClass(?X) :- TRIPLE(?X, owl:unionOf, ?L1), in(?L1,?C), next(?L1,?L2), nonlast(?L2) .

disj(!N,?C1,?L2), auxClass(?L1) :-
	nonfirstDisj(?L1), next(?L1,?L2), nonlast(?L2), in(?L1,?C1) .
disj(?L1,?C1,?C2), auxClass(?L1) :-
	nonfirstDisj(?L1), next(?L1,?L2), last(?L2), in(?L1,?C1), in(?L2,?C2) .

%%% The other classes are "main classes" that are not normalised:
nf:isMainClass(?X) :- class(?X), ~auxClass(?X) .

%%% Normalise auxiliary nested class expressions:
repOf(?X,?X) :- nf:isMainClass(?X) . % keep main classes unchanged
nf:exists(!N,?P,?RY), repOf(?X,!N) :- 
        synEx(?Y,?P,?X), repOf(?Y,?RY) .
nf:conj(!N,?R1,?R2), repOf(?X,!N) :- 
        synConj(?X,?C1,?C2), repOf(?C1,?R1), repOf(?C2,?R2) .
nf:disj(!N,?R1,?R2), repOf(?X,!N)  :- 
        disj(?X,?C1,?C2), repOf(?C1,?R1), repOf(?C2,?R2) .

%%% Initialise subsumption axioms:
                         prepareSco(?X,?Y) :- TRIPLE(?X, rdfs:subClassOf, ?Y) .
      #[name("equiv")]
      prepareSco(?X,?Y), prepareSco(?Y,?X) :- TRIPLE(?X, owl:equivalentClass, ?Y) .

nf:subClassOf(?RX,?RY) :- prepareSco(?X,?Y), repOf(?X,?RX), repOf(?Y,?RY) .

%%% new predicates to express different kinds of sequents (see also NF0-NF3 on p143, Fig. 6.1)
nf:class(?C) :- nf:isMainClass(?C) .
nf:subClassConj(?D,?E,?Y),  nf:class(?Y) :- nf:conj(?Y,?D,?E) .
nf:subClassEx(?R,?B,?Y), nf:class(?Y)  :- nf:exists(?Y,?R,?B) . 
nf:supClassEx(?Y,?R,?B), nf:class(?Y)  :- nf:exists(?Y,?R,?B) .
% NF4
#[name("NF4")]
nf:subClassOf(?X, ?C), nf:subClassOf(?X, ?D) :- nf:conj(?X,?C,?D). 

% Precompute role hierarchy: 
directSubProp(?R,?S) :- TRIPLE(?R,rdfs:subPropertyOf,?S) .
#[name("role_hierarchy")]
nf:subProp(?P,?P) :- nf:supClassEx(_,?P,_) .
#[name("role_hierarchy")]
nf:subProp(?R,?T) :- directSubProp(?R,?S), nf:subProp(?S,?T) .


%% Initialize classification algorithm with input sequents

% A ⊑ B
inf:subClassOf(?A,?B) :- nf:subClassOf(?A,?B) .
% A ⊓ B ⊑ C
#[name("taut")]
inf:subClassConj(?A,?B,?C) :- nf:subClassConj(?A,?B,?C) .
% ∃R.A ⊑ B
#[name("taut")]
inf:subClassEx(?R,?A,?B) :- nf:subClassEx(?R,?A,?B) .
% A ⊑ ∃R.B
#[name("taut")]
inf:supClassEx(?A,?R,?B) :- nf:supClassEx(?A,?R,?B) .

%%% Inference rules, instantiated for all possible combinations of types of sequents

% CR1
#[name("CR1")]
inf:subClassOf(?A,?A) :- nf:class(?A) .

% CR2
#[name("CR2")]
inf:subClassOf(?A,owl:Thing) :- nf:class(?A) .
#[name("CR2_⊥")]
inf:subClassOf(owl:Nothing, ?A) :- nf:class(?A).


% CR3
#[name("CR3")]
inf:subClassOf(?A1,?A3) :- inf:subClassOf(?A1,?A2), inf:subClassOf(?A2,?A3) .
#[name("CR3")]
inf:subClassConj(?A1,?A2,?A4) :- inf:subClassConj(?A1,?A2,?A3), inf:subClassOf(?A3,?A4) .
#[name("CR3")]
inf:subClassEx(?R,?A1,?A3) :- inf:subClassEx(?R,?A1,?A2), inf:subClassOf(?A2,?A3) .
#[name("CR3")]
inf:supClassEx(?A1,?R,?A3) :- inf:subClassOf(?A1,?A2), inf:supClassEx(?A2,?R,?A3) .

% CR4
#[name("CR4")]
inf:subClassOf(?A,?B) :- inf:subClassOf(?A,?A1), inf:subClassOf(?A,?A2), inf:subClassConj(?A1,?A2,?B) .
#[name("CR4")]
inf:subClassConj(?A1,?A2,?B) :- inf:subClassConj(?A1,?A2,?A3), inf:subClassConj(?A1,?A2,?A4), inf:subClassConj(?A3,?A4,?B) .
#[name("CR4")]
inf:subClassEx(?R,?A,?B) :- inf:subClassEx(?R,?A,?A1), inf:subClassEx(?R,?A,?A2), inf:subClassConj(?A1,?A2,?B) .

% CR5, extended for role hierarchies
#[name("CR5")]
inf:subClassOf(?A,?B) :- inf:supClassEx(?A,?R,?A1), inf:subClassOf(?A1,?B1), nf:subProp(?R,?S), inf:subClassEx(?S,?B1,?B) .

% R_\bot from ELK
#[name("R_⊥ (ELK)")]
inf:subClassOf(?E,owl:Nothing) :-
	inf:supClassEx(?E,?R,?C), inf:subClassOf(?C,owl:Nothing) .

%%% Extract final results for main classes

mainSubClassOf(?A,?B) :-
	inf:subClassOf(?A,?B), nf:isMainClass(?A), nf:isMainClass(?B) .
#[name("equiv")]
mainEquivClass(?A,?B) :- mainSubClassOf(?A,?B), mainSubClassOf(?B,?A).


@export mainSubClassOf :- csv{resource="out1.csv.gz"} .
@export mainEquivClass :- csv{resource="out2.csv.gz"} .