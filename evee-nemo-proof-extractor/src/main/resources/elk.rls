% OWL EL Reasoning from OWL/RDF
% See https://github.com/knowsys/nemo-examples/tree/main/examples/owl-el/from-owl-rdf
%
% This example shows how Nemo can be used to reason in the ontology language OWL EL,
% based on input that is the W3C standard encoding of an OWN ontology in RDF, using
% the NTriples syntax.

% elk.rls:
%
% Complete reasoner, producing all inferred class subsumptions as output.
%
% This ruleset normalises an EL ontology in OWL/RDF encoding.
% Unsupported OWL EL features include: oneOf, allDisjoint.
%
% The ruleset computes facts for the following predicates:
%  nf:isMainClass(?C): ?C is an "interesting" class (not just an auxiliary class expression)
%  nf:isSubClass(?C): ?C occurs in a subclass position (i.e., negatively) 
%  nf:conj(?C,?D1,?D2): ?C is the conjunction of ?D1 and ?D2
%  nf:exists(?C,?P,?D): ?C is the existential restriction of property ?P with values from ?D
%  nf:subClassOf(?C,?D): ?C is syntactically specified to be a subclass of ?D 
%  nf:subPropChain(?S1,?S2,?R): there was a role chain axiom ?S1 o ?S2 -> ?R
%  nf:subProp(?R,?S): ?R is a subproperty of ?S (directly or indirectly) 

@prefix nf: <http://rulewerk.semantic-web.org/normalForm/> .
@prefix inf: <http://rulewerk.semantic-web.org/inferred/> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix sct: <http://www.ihtsdo.org/owlname#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

% Read data from Turtle file:
@import TRIPLE :- rdf{resource="ont.ttl"} .

%%% Mark classes:
ClassObject(owl:someValuesFrom) .
ClassObject(rdf:first) .
ClassObject(rdfs:subClassOf) .
ClassObject(owl:equivalentClass) .
ClassSubject(rdfs:subClassOf) .
ClassSubject(owl:equivalentClass) .
class(?O) :- TRIPLE(?X, ?P, ?O), ClassObject(?P) .
class(?X) :- TRIPLE(?X, ?P, ?O), ClassSubject(?P) .

%%% Distinguish auxiliary class expressions from primary classes:

%% Mark auxiliary existential role restrictions:
synEx(?Y,?P,?X), auxClass(?X) :- TRIPLE(?X, owl:someValuesFrom, ?Y), TRIPLE(?X, owl:onProperty, ?P) .

%% Mark auxiliary lists:

next(?L1,?L2) :- TRIPLE(?L1,rdf:rest,?L2) .
    last(?Ln) :- next(?Ln,rdf:nil) .
  nonlast(?L) :- next(?L,?Ln), last(?Ln) .
 nonlast(?L1) :- next(?L1,?L2), nonlast(?L2) .
    in(?L,?C) :- TRIPLE(?L,rdf:first,?C) .

firstCon(?L1)     :- TRIPLE(?X, owl:intersectionOf, ?L1) .
nonfirstCon(?L2)  :- firstCon(?L1), next(?L1,?L2) .
nonfirstCon(?L2)  :- nonfirstCon(?L1), next(?L1,?L2) .

firstProp(?L1)    :-  TRIPLE(?R,owl:propertyChainAxiom,?L1).
nonfirstProp(?L2) :- firstProp(?L1), next(?L1,?L2) .
nonfirstProp(?L2) :- nonfirstProp(?L1), next(?L1,?L2) .

%% Initialise disjointness:
#[name("disjoint")]
TRIPLE(!C, owl:intersectionOf, !L1), TRIPLE(!L1,rdf:first,?X), 
TRIPLE(!L1,rdf:rest,!L2), TRIPLE(!L2,rdf:first,?Y), TRIPLE(!L2,rdf:rest,rdf:nil),
TRIPLE(!C,rdfs:subClassOf, owl:Nothing)
	:- TRIPLE(?X,owl:disjointWith,?Y) .

% Mark conjunctions:
synConj(?X,?C1,?C2), auxClass(?X) :-
	TRIPLE(?X, owl:intersectionOf, ?L1), next(?L1,?L2), last(?L2), in(?L1,?C1), in(?L2,?C2) .
synConj(?X,?C1,?L2), auxClass(?X) :-
	TRIPLE(?X, owl:intersectionOf, ?L1), next(?L1,?L2), nonlast(?L2), in(?L1,?C1) .
synConj(?L1,?C1,?L2), auxClass(?L1) :-
	nonfirstCon(?L1), next(?L1,?L2), nonlast(?L2), in(?L1,?C1) .
synConj(?L1,?C1,?C2), auxClass(?L1) :-
	nonfirstCon(?L1), next(?L1,?L2), last(?L2), in(?L1,?C1), in(?L2,?C2) .

%%% The other classes are "main classes" that are not normalised:
nf:isMainClass(?X) :- class(?X), ~auxClass(?X) .
nf:isMainClass(owl:Nothing) .

%%% Normalise auxiliary nested class expressions:
           repOf(?X,?X) :- nf:isMainClass(?X) . % keep main classes unchanged
   synExRep(?X,?P,?Rep) :- synEx(?Y,?P,?X), repOf(?Y,?Rep) .
nf:exists(!New,?P,?Rep) :- synExRep(?X,?P,?Rep) .
           repOf(?X,?N) :- synExRep(?X,?P,?Rep), nf:exists(?N,?P,?Rep) .
		%  nf:exists(!New,?P,?Rep) :- synEx(?Y,?P,?X), repOf(?Y,?Rep) .
		%         repOf(?X,?N) :- synEx(?Y,?P), repOf(?Y,?Rep), nf:exists(?N,?P,?Rep) .
nf:conj(!New,?R1,?R2) :- synConj(?X,?C1,?C2), repOf(?C1,?R1), repOf(?C2,?R2) .
         repOf(?X,?N) :- synConj(?X,?C1,?C2), repOf(?C1,?R1), repOf(?C2,?R2), nf:conj(?N,?R1,?R2) .

%%% normalise  property chains:
#[name("trans")]
auxPropChain(?R,?R,?R), chainProp(?R) :- 
		TRIPLE(?R, rdf:type, owl:TransitiveProperty) .
auxPropChain(?S,?T,?R), chainProp(?R), chainProp(?S), chainProp(?T):-
        TRIPLE(?R,owl:propertyChainAxiom,?L1), in(?L1,?S), next(?L1,?L2), in(?L2,?T), last(?L2) .
auxPropChain(?S,?L2,?R), chainProp(?R), chainProp(?S) :- 
        TRIPLE(?R,owl:propertyChainAxiom,?L1), in(?L1,?S), next(?L1,?L2), nonlast(?L2) .
auxPropChain(?S,?L2,?L1), chainProp(?S), auxProp(?L1) :-  
        nonfirstProp(?L1), next(?L1,?L2), nonlast(?L2), in(?L1, ?S).
auxPropChain(?S, ?T, ?L1), chainProp(?S), chainProp(?T), auxProp(?L1) :- 
        nonfirstProp(?L1), next(?L1,?L2), last(?L2), in(?L1, ?S), in(?L2, ?T).

repOfProp(?R,?R)              :- chainProp(?R), ~auxProp(?R).
repOfProp(?R,!New)            :- auxProp(?R), ~chainProp(?R).
nf:subPropChain(?S1,?S2,?S)   :- auxPropChain(?R1,?R2,?R), repOfProp(?R1,?S1), repOfProp(?R2,?S2), repOfProp(?R,?S) .

%%% Initialise subsumption axioms:
                         prepareSco(?X,?Y) :- TRIPLE(?X, rdfs:subClassOf, ?Y) .
		#[name("equiv")]
      prepareSco(?X,?Y), prepareSco(?Y,?X) :- TRIPLE(?X, owl:equivalentClass, ?Y) .
nf:subClassOf(?RX,?RY), nf:isSubClass(?RX) :- prepareSco(?X,?Y), repOf(?X,?RX), repOf(?Y,?RY) .

%%% Mark classes in subclass position recursively:
                     nf:isSubClass(?D) :- nf:exists(?C, ?P, ?D), nf:isSubClass(?C) .
nf:isSubClass(?C1), nf:isSubClass(?C2) :- nf:conj(?X, ?C1, ?C2), nf:isSubClass(?X) .

%%% Precompute role hierarchy:
directSubProp(?R,?S) :- TRIPLE(?R,rdfs:subPropertyOf,?S) .
% Initialise role hierarchy only for roles in subclass positions or role chains:
#[name("R_0")]
nf:subProp(?P,?P) :- chainProp(?P) .
#[name("R_0")]
nf:subProp(?P,?P) :- auxProp(?R), repOfProp(?R,?P) .
#[name("R_0")]
nf:subProp(?P,?P) :- nf:exists(?C,?P,?D), nf:isSubClass(?C) .
#[name("R_⊑")]
nf:subProp(?R,?T) :- directSubProp(?R,?S), nf:subProp(?S,?T) .


%%% Start classification for all named classes:

inf:init(?C) :- nf:isMainClass(?C) .

%%% Inference rules (from "The Incredible ELK", Fig. 3)

% R_0
#[name("R_0")]
inf:subClassOf(?C,?C) :- inf:init(?C) .

% R_\top
#[name("R_⊤")]
inf:subClassOf(?C,owl:Thing) :-
	nf:isMainClass(?C), nf:isSubClass(owl:Thing) .

% R_\sqcap^-
#[name("R_⊓^-")]
inf:subClassOf(?C,?D1), inf:subClassOf(?C,?D2) :-
	inf:subClassOf(?C,?Y), nf:conj(?Y,?D1,?D2) .

% R_\sqcap^+
#[name("R_⊓^+")]
inf:subClassOf(?C,?Y) :-
	inf:subClassOf(?C,?D1), inf:subClassOf(?C,?D2),
	nf:conj(?Y,?D1,?D2), nf:isSubClass(?Y) .

% R_\exists^-
#[name("R_∃^-")]
inf:ex(?E,?R,?C) :- inf:subClassOf(?E,?Y), nf:exists(?Y,?R,?C) .

% R_\exists^+
#[name("R_∃^+")]
inf:subClassOf(?E,?Y) :-
	inf:ex(?E,?R,?C), inf:subClassOf(?C,?D),
	nf:subProp(?R,?S), nf:exists(?Y,?S,?D), nf:isSubClass(?Y) .

% R_\sqsubseteq
#[name("R_⊑")]
inf:subClassOf(?C,?E) :-
	inf:subClassOf(?C,?D), nf:subClassOf(?D,?E) .

% R_\circ
#[name("R_∘")]
inf:ex(?E,?S,?D) :-
	inf:ex(?E,?R1,?C), inf:ex(?C,?R2,?D),
	nf:subProp(?R1,?S1), nf:subProp(?R2,?S2), nf:subPropChain(?S1,?S2,?S) .

% R_\bot
#[name("R_⊥")]
inf:subClassOf(?E,owl:Nothing) :-
	inf:ex(?E,?R,?C), inf:subClassOf(?C,owl:Nothing) .

% R_init
inf:init(?C) :- inf:ex(?E,?R,?C) .

%%% Extract final results for main classes

mainSubClassOf(?A,?B) :-
	inf:subClassOf(?A,?B), nf:isMainClass(?A), nf:isMainClass(?B) .

mainEquivClass(?A,?B) :- mainSubClassOf(?A,?B), mainSubClassOf(?B,?A).

@output mainSubClassOf, mainEquivClass.